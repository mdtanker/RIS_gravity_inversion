**Description of the desired feature:**
<!--
Add as much detail as you can in your description below. If possible, include an
example of how you would like to use this feature (even better if it's a code
example).
-->

I'm working on a 3D gravity inversion for my Ph.D. to model the bathymetry beneath a float ice shelf. I'm using a vertical-prisms approach, and I'm mostly interesting in a geometry inversion, where each prism's density remains unchanged, but the prisms' tops or bottoms are updated to minimize the observed gravity - forward gravity misfit. While this inversion is in the early stages, I'm already using several `harmonica` tools so I think it would be great to include a fully supported inversion module in harmonica. 

## Current state of inversion
### Model setup
* input an arbitrary number of layer topographies (i.e. ice surface, ice base, bathymetry, basement, Moho) 
     * [`xarray.load_dataset()`](https://docs.xarray.dev/en/latest/generated/xarray.load_dataset.html) to load netcdf's as grids
     * [`pygmt.grdsample()`](https://www.pygmt.org/latest/api/generated/pygmt.grdsample.html) to make sure all grids' extents match
* create a layer of vertical prisms between each set of grids 
     * [`harmonica.prism_layer()`](https://www.fatiando.org/harmonica/latest/api/generated/harmonica.DatasetAccessorPrismLayer.html#harmonica.DatasetAccessorPrismLayer)
          *  example: for water layer: `surface` = ice base, `reference` = bathymetry
     *  assign a density to each prism (currently using constant density within each layer)
          * `prism_layer(... properties={'density':water_density)`  
     * allow different cell sizes between layers
          * if lower grid cell size doesn't match upper grid's, use [`pygmt.grdtrack()`](https://www.pygmt.org/latest/api/generated/pygmt.grdtrack.html) to sample the lower grids values at the grid's prism locations 
<img src="https://user-images.githubusercontent.com/81199856/172079573-b9fc9835-2042-4835-a082-0305392d73e9.png" width="300" >

*  calculate forward gravity of each layer
     * [`harmonica.prism_layer.gravity()`](https://www.fatiando.org/harmonica/latest/api/generated/harmonica.prism_gravity.html) for each prism layer
 <img src="https://user-images.githubusercontent.com/81199856/172271180-91ed36e1-891a-4d55-9422-b2371d8b7fa1.png" width="1000" >         

* calculate gravity misfit 
     * add forward gravities for all layers, and subtract from observed gravity
 <img src="https://user-images.githubusercontent.com/81199856/172271212-ea9b1743-5f41-435a-b1b0-808cb32c141f.png" width="600" >   

### run geometry inversion
* designate an `active_layer` ex: `active_layer='bathymetry_prisms'` 
* each iteration of the inversion will yield a `surface_correction`
     * applied to the `active_layer` tops, as well as the bottoms of the layer above `active_layer`
          * [`harmonica.DatasetAccessorPrismLayer.update_top_bottom()`](https://www.fatiando.org/harmonica/latest/api/generated/harmonica.DatasetAccessorPrismLayer.html#harmonica.DatasetAccessorPrismLayer) 
  
* currently this inversion works by finding the least-squares solution to the matrix equation Ax=b, where A is the Jacobian matrix of the vertical derivative of gravity acceleration, and b is the initial misfit between observed and forward gravity.  
     * the least squares solution is found with [`scipy.sparse.linalg.lsqr`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.linalg.lsqr.html) 
     * the vertical derivative is approximated with the Hammer approximation of prisms, using annuluses as opposed to prisms.
<img src="https://user-images.githubusercontent.com/81199856/172271303-a10a769b-390f-47d0-b304-209553254f2c.png" width="1000" >   


 list some of the features specific to my use case I would hope to be included, some which are more necessary than others. Bolded features are already available / included in my initial inversion code.
 ## Features to add:
* enforce constraint point (points of known bathymetry) by multiplying `surface_correction` by a constraints grid 
          * 0's at constraints, linearly increasing to 1's at specified distance from nearest constraints
          * [`scipy.spatial.cKDTree.query()`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.cKDTree.query.html) to get grid of minimum distances to constraints
          * [`gmt grdmath`](https://docs.generic-mapping-tools.org/latest/grdmath.html) LE and GE to set constraints to 0 and other points to 1
          * [`gmt grdblend`](https://docs.generic-mapping-tools.org/latest/grdblend.html) to merge the clipped grids
          * and [`rioxarray.interpolate_na()`](https://corteva.github.io/rioxarray/stable/rioxarray.html#rioxarray.raster_array.RasterArray.interpolate_na) to linearly interpolate between 0 and 1
 <img src="https://user-images.githubusercontent.com/81199856/172266356-a9dfd52c-5083-4764-979a-750495945edd.png" width="200" >    

**Are you willing to help implement and maintain this feature?** 
<!--
Every feature we add is code that we will have to maintain and keep updated.
Please let us know if you're willing to help maintain this feature in the future.
-->
