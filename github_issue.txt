**Description of the desired feature:**
<!--
Add as much detail as you can in your description below. If possible, include an
example of how you would like to use this feature (even better if it's a code
example).
-->

I'm working on a 3D gravity inversion for my Ph.D. to model the bathymetry beneath a float ice shelf. I'm using a vertical-prisms approach, and I'm mostly interesting in a geometry inversion, where each prism's density remains unchanged, but the prisms' tops or bottoms are updated to minimize the observed gravity - forward gravity misfit. While this inversion is in the early stages, I'm already using several `harmonica` tools so I think it would be great to include a fully supported inversion module in harmonica. 

Below is an outline of the current state of my inversion. 
* input netcdf's of layer topographies (i.e. ice surface, ice base, bathymetry, basement, Moho) 
     * [`xarray.load_dataset()`](https://docs.xarray.dev/en/latest/generated/xarray.load_dataset.html) to load grids
     * [`pygmt.grdsample()`](https://www.pygmt.org/latest/api/generated/pygmt.grdsample.html) to make sure all grids' extents match
* create layers of vertical prisms between each grid
     * [`harmonica.prism_layer()`](https://www.fatiando.org/harmonica/latest/api/generated/harmonica.DatasetAccessorPrismLayer.html#harmonica.DatasetAccessorPrismLayer)
          *  example: for water layer: `surface` = ice base, `reference` = bathymetry
     *  assign a density to each prism (currently using constant density within each layer)
          * `prism_layer(... properties={'density':water_density)`  
     * allow different cell sizes between layers
          * if lower grid cell size doesn't match upper grid's, use [`pygmt.grdtrack()`](https://www.pygmt.org/latest/api/generated/pygmt.grdtrack.html) to sample the lower grids values at the grid's prism locations 
<img src="https://user-images.githubusercontent.com/81199856/172079573-b9fc9835-2042-4835-a082-0305392d73e9.png" width="300" >

*  calculate forward gravity of these layers
     * [`harmonica.prism_layer.gravity()`](https://www.fatiando.org/harmonica/latest/api/generated/harmonica.prism_gravity.html) for each prism layer
* calculate gravity misfit 
     * add forward gravities for all layers, and subtract from observed gravity
## run geometry inversion
* designate an `active_layer` ex: `active_layer='bathymetry_prisms'` 
* each iteration of the inversion will yield a `surface_correction`
     * applied to the `active_layer` tops, as well as the bottoms of the layer above `active_layer`
          * [`harmonica.DatasetAccessorPrismLayer.update_top_bottom()`](https://www.fatiando.org/harmonica/latest/api/generated/harmonica.DatasetAccessorPrismLayer.html#harmonica.DatasetAccessorPrismLayer) 
     * enforce constraint point (points of known bathymetry) by multiplying `surface_correction` by a constraints grid 
          * 0's at constraints, linearly increasing to 1's at specified distance from nearest constraints
          * [`scipy.spatial.cKDTree.query()`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.cKDTree.query.html) to get grid of minimum distances to constraints
          * [`gmt grdmath`](https://docs.generic-mapping-tools.org/latest/grdmath.html) LE and GE to set constraints to 0 and other points to 1
          * [`gmt grdblend`](https://docs.generic-mapping-tools.org/latest/grdblend.html) to merge the clipped grids
          * and [`rioxarray.interpolate_na()`](https://corteva.github.io/rioxarray/stable/rioxarray.html#rioxarray.raster_array.RasterArray.interpolate_na) to linearly interpolate between 0 and 1
     
* currently I'm inverting with [`scipy.sparse.linalg.lsqr`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.linalg.lsqr.html) on a 
     * 
 list some of the features specific to my use case I would hope to be included, some which are more necessary than others. Bolded features are already available / included in my initial inversion code.


**Are you willing to help implement and maintain this feature?** 
<!--
Every feature we add is code that we will have to maintain and keep updated.
Please let us know if you're willing to help maintain this feature in the future.
-->
